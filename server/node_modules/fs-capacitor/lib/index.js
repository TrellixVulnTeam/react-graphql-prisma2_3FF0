"use strict";

exports.__esModule = true;
exports.default = exports.WriteStream = exports.ReadStream = exports.ReadAfterDestroyedError = void 0;

var _crypto = _interopRequireDefault(require("crypto"));

var _fs = _interopRequireDefault(require("fs"));

var _os = _interopRequireDefault(require("os"));

var _path = _interopRequireDefault(require("path"));

var _readableStream = _interopRequireDefault(require("readable-stream"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const { Readable, Writable } = _readableStream.default;
let haveCheckedSignalListeners = false;

function checkSignalListeners() {
  haveCheckedSignalListeners = true;
  if (!process.listeners("SIGINT").length)
    process.emitWarning(
      "There are no listeners for SIGINT. If your application receives a SIGINT signal, it is possible that some temporary files will not be cleaned up. Please see https://github.com/mike-marcacci/fs-capacitor#ensuring-cleanup-on-termination-by-process-signal"
    );
  if (!process.listeners("SIGTERM").length)
    process.emitWarning(
      "There are no listeners for SIGTERM. If your application receives a SIGTERM signal, it is possible that some temporary files will not be cleaned up. Please see https://github.com/mike-marcacci/fs-capacitor#ensuring-cleanup-on-termination-by-process-signal"
    );
  if (!process.listeners("SIGHUP").length)
    process.emitWarning(
      "There are no listeners for SIGHUP. If your application receives a SIGHUP signal, it is possible that some temporary files will not be cleaned up. Please see https://github.com/mike-marcacci/fs-capacitor#ensuring-cleanup-on-termination-by-process-signal"
    );
}

class ReadAfterDestroyedError extends Error {}

exports.ReadAfterDestroyedError = ReadAfterDestroyedError;

class ReadStream extends Readable {
  constructor(writeStream, name) {
    super({
      autoDestroy: true
    });
    this._pos = 0;
    this._writeStream = writeStream;
    this.name = name;
  }

  _read(n) {
    if (this.destroyed) return;

    if (typeof this._writeStream._fd !== "number") {
      this._writeStream.once("ready", () => this._read(n));

      return;
    }

    let buf = Buffer.allocUnsafe(n);

    _fs.default.read(
      this._writeStream._fd,
      buf,
      0,
      n,
      this._pos,
      (error, bytesRead) => {
        if (error) this.destroy(error);

        if (bytesRead) {
          this._pos += bytesRead;
          this.push(buf.slice(0, bytesRead));
          return;
        }

        if (this._writeStream._writableState.finished) {
          this.push(null);
          return;
        }

        const retry = () => {
          this._writeStream.removeListener("finish", retry);

          this._writeStream.removeListener("write", retry);

          this._read(n);
        };

        this._writeStream.addListener("finish", retry);

        this._writeStream.addListener("write", retry);
      }
    );
  }
}

exports.ReadStream = ReadStream;

class WriteStream extends Writable {
  constructor() {
    if (!haveCheckedSignalListeners) checkSignalListeners();
    super({
      autoDestroy: false
    });
    this._pos = 0;
    this._readStreams = new Set();

    this._cleanupSync = () => {
      process.removeListener("exit", this._cleanupSync);
      if (typeof this._fd === "number")
        try {
          _fs.default.closeSync(this._fd);
        } catch (error) {}

      try {
        _fs.default.unlinkSync(this._path);
      } catch (error) {}
    };

    _crypto.default.randomBytes(16, (error, buffer) => {
      if (error) {
        this.destroy(error);
        return;
      }

      this._path = _path.default.join(
        _os.default.tmpdir(),
        `capacitor-${buffer.toString("hex")}.tmp`
      );

      _fs.default.open(this._path, "wx+", 0o600, (error, fd) => {
        if (error) {
          this.destroy(error);
          return;
        }

        process.addListener("exit", this._cleanupSync);
        this._fd = fd;
        this.emit("ready");
      });
    });
  }

  _final(callback) {
    if (typeof this._fd !== "number") {
      this.once("ready", () => this._final(callback));
      return;
    }

    callback();
  }

  _write(chunk, encoding, callback) {
    if (typeof this._fd !== "number") {
      this.once("ready", () => this._write(chunk, encoding, callback));
      return;
    }

    _fs.default.write(this._fd, chunk, 0, chunk.length, this._pos, error => {
      if (error) {
        callback(error);
        return;
      }

      this._pos += chunk.length;
      this.emit("write");
      callback();
    });
  }

  _destroy(error, callback) {
    if (typeof this._fd !== "number") {
      this.once("ready", () => this._destroy(error, callback));
      return;
    }

    this._destroyPending = () => {
      process.removeListener("exit", this._cleanupSync);

      const unlink = error => {
        _fs.default.unlink(this._path, unlinkError => {
          this._fd = null;
          callback(unlinkError || error);
        });
      };

      if (typeof this._fd === "number")
        _fs.default.close(this._fd, closeError => {
          unlink(closeError || error);
        });
      else callback(error);
    };

    if (this._readStreams.size === 0) this._destroyPending();
    else if (error)
      for (let readStream of this._readStreams) readStream.destroy(error);
  }

  createReadStream(name) {
    if (this.destroyed)
      throw new ReadAfterDestroyedError(
        "A ReadStream cannot be created from a destroyed WriteStream."
      );
    const readStream = new ReadStream(this, name);

    this._readStreams.add(readStream);

    const remove = () => {
      this._readStreams.delete(readStream);

      if (this._destroyPending && this._readStreams.size === 0)
        this._destroyPending();
      readStream.removeListener("end", remove);
      readStream.removeListener("close", remove);
    };

    readStream.addListener("end", remove);
    readStream.addListener("close", remove);
    return readStream;
  }
}

exports.WriteStream = WriteStream;
var _default = WriteStream;
exports.default = _default;
